"""
========================== Introduction: Instagram Unfollow Bot ================================

This Python script automates the process of unfollowing Instagram accounts
that do not follow you back. It reads a list of usernames from an Excel file
and removes followers by interacting with the Instagram web interface using Selenium.

-----------------------------------------------------------------------------------------------
⚙️ Key Features:
-----------------------------------------------------------------------------------------------
- Works on an existing Excel file and updates the 'Done ?' column in-place.
- Marks each action as successful ("✅"), failed ("❌"), or skipped.
- Mimics human behavior with random delays, scrolling, and slight mouse movements.
- Handles confirmation dialogs for unfollowing and waits for the button to change.
- Loads sensitive credentials (username/password) from a .env file or prompts securely at runtime.
- Saves the Excel file periodically to prevent data loss.
- Designed for safe, gradual operation to reduce the risk of being blocked by Instagram.
- Supports both Hebrew and English interface buttons ("Following" / "במעקב" / "ביטול מעקב").

-----------------------------------------------------------------------------------------------
🧠 Notes:
-----------------------------------------------------------------------------------------------
- Requires an Excel file generated by the companion script: "Instagram Data Preparation Script".
- Make sure to log in with a valid Instagram account and keep your credentials private.
- Avoid running the script too quickly — Instagram may temporarily block automated behavior.
- Works best with a stable network connection and updated Chrome browser.

-----------------------------------------------------------------------------------------------
👤 Author: Bar Cohen
💻 Language: Python 3.13
📚 Libraries: selenium, pandas, python-dotenv, openpyxl, webdriver-manager, random, time, os
================================================================================================
"""

import time
import random
import os
from getpass import getpass
from dotenv import load_dotenv  # pip install python-dotenv
import pandas as pd

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver import ActionChains
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.common.exceptions import (
    NoSuchElementException,
    ElementClickInterceptedException,
    InvalidSessionIdException,
    StaleElementReferenceException
)
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# ------------------------------------------ Configurable settings ------------------------------------------
# Defines key automation parameters such as delay ranges, file paths, and saving intervals.
SAVE_EVERY = 5
MIN_DELAY = 2
MAX_DELAY = 6
LONG_BREAK_EVERY = 20
LONG_BREAK_MIN = 60
LONG_BREAK_MAX = 150
EXCEL_IN = "not_following_back_detailed.xlsx"
# ----------------------------------------------------------------------------------------------------------

def human_delay(a=MIN_DELAY, b=MAX_DELAY):
    """
    Introduces a random sleep between actions to simulate human behavior.
    Helps reduce detection and throttling by Instagram.
    """
    time.sleep(random.uniform(a, b))


def small_mouse_move(driver, element=None):
    """
    Moves the mouse slightly or randomly near a target element to mimic human movement.
    """
    try:
        ac = ActionChains(driver)
        if element:
            # Calculate random offset within the element's bounds
            w = element.size['width'] if element.size['width'] > 0 else 10
            h = element.size['height'] if element.size['height'] > 0 else 10
            offset_x = random.randint(1, max(1, min(10, w//2)))
            offset_y = random.randint(1, max(1, min(10, h//2)))
            ac.move_to_element_with_offset(element, offset_x, offset_y).perform()
        else:
            # Random move within the page body
            body = driver.find_element(By.TAG_NAME, "body")
            ac.move_to_element_with_offset(body, random.randint(0, 5), random.randint(0, 5)).perform()
    except Exception:
        pass


def random_scroll(driver):
    """
    Randomly scrolls the page up and down to make the automation appear human-like.
    """
    try:
        scrolls = random.randint(1, 4)
        for _ in range(scrolls):
            amount = random.randint(100, 700)
            driver.execute_script(f"window.scrollBy(0, {amount});")
            time.sleep(random.uniform(0.2, 0.9))
        if random.random() < 0.3:
            driver.execute_script("window.scrollBy(0, -200);")
    except Exception:
        pass


def find_unfollow_button(driver):
    """
    Searches for the 'Following' button (or its Hebrew equivalents) on a user's Instagram profile.
    Returns the button element if found, otherwise None.
    """
    xpath_candidates = [
        "//button[contains(., 'Following')]",
        "//button[contains(., 'במעקב')]",
        "//button[contains(., 'עוקב')]",
        "//button//*[text()='Following']/..",
        "//button[contains(., 'Following ')]",
    ]
    buttons = []
    for xp in xpath_candidates:
        try:
            found = driver.find_elements(By.XPATH, xp)
            if found:
                buttons.extend(found)
        except Exception:
            pass
    for btn in buttons:
        try:
            txt = btn.text.strip()
            if txt and ("Following" in txt or "עוקב" in txt or "במעקב" in txt or txt.lower().startswith("following")):
                return btn
        except Exception:
            pass
    return None


def start_driver():
    """
    Initializes a Chrome WebDriver using WebDriver Manager.
    Returns a ready-to-use driver instance.
    """
    options = webdriver.ChromeOptions()
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
    return driver


def do_login(driver, username, password):
    """
    Logs into Instagram using the provided credentials.
    Uses human-like typing and random delays for realism.
    """
    driver.get("https://www.instagram.com/accounts/login/")
    human_delay(4, 8)
    username_input = driver.find_element(By.NAME, "username")
    password_input = driver.find_element(By.NAME, "password")

    # Simulate typing username
    for ch in username:
        username_input.send_keys(ch)
        time.sleep(random.uniform(0.03, 0.12))

    human_delay(0.5, 1.2)

    # Simulate typing password
    for ch in password:
        password_input.send_keys(ch)
        time.sleep(random.uniform(0.03, 0.12))

    # Submit login
    human_delay(0.3, 1.0)
    password_input.send_keys(Keys.ENTER)
    human_delay(6, 10)
    random_scroll(driver)
    human_delay(2, 4)


def main():
    """
    Main automation workflow:
    - Loads credentials from environment or user input
    - Reads usernames from Excel
    - Logs into Instagram
    - Iterates over each user and attempts to unfollow them
    - Saves progress periodically and at the end
    - Converts profile URLs into clickable hyperlinks in the Excel file
    """
    load_dotenv("Personal details.env") # It is advisable to create it beforehand but not required.
                                        # ״.env״ file is a simple text file that contains environment variables for software.
    INSTAGRAM_USER = os.getenv("INSTAGRAM_USER") or input("Enter your username (or leave blank to skip): ")
    INSTAGRAM_PASS = os.getenv("INSTAGRAM_PASS")
    if not INSTAGRAM_PASS:
        INSTAGRAM_PASS = getpass("Enter your password (not saved in code): ")

    # Load Excel file as text to preserve formatting
    df = pd.read_excel(EXCEL_IN, dtype=str)

    # Ensure required columns exist
    if "Done ?" not in df.columns:
        df["Done ?"] = ""  # Explicitly text
    if "Profile URL" not in df.columns:
        df["Profile URL"] = ""

    # Filter rows to process only unmarked entries
    to_process = df[df["Done ?"].isnull() | (df["Done ?"].astype(str).str.strip() == "")].copy()
    total_to_run = len(to_process)
    if total_to_run == 0:
        print("No users to process (all rows already marked in 'Done ?').")
        return

    print(f"Starting unfollow process for {total_to_run} users.")

    # Start browser and log in
    driver = start_driver()
    try:
        do_login(driver, INSTAGRAM_USER, INSTAGRAM_PASS)
    except Exception as e:
        print("⚠️ Initial login failed:", e)
        driver.quit()
        return

    processed = 0

    # ------------------------------------------ Main user iteration loop ------------------------------------------
    for index, row in to_process.head(total_to_run).iterrows():
        username = str(row["Username"]).strip()
        if not username:
            df.at[index, "Done ?"] = "Skipped"
            continue

        profile_url = f"https://www.instagram.com/{username}/"
        df.at[index, "Profile URL"] = profile_url  # Save URL for reference

        try:
            # Attempt to open the profile page
            try:
                driver.get(profile_url)
            except InvalidSessionIdException:
                # Restart browser if session dies
                print("⚠️ Browser session lost. Saving progress and restarting...")
                df.to_excel(EXCEL_IN, index=False)
                try:
                    driver.quit()
                except Exception:
                    pass
                driver = start_driver()
                do_login(driver, INSTAGRAM_USER, INSTAGRAM_PASS)
                driver.get(profile_url)

            # Add human-like delays
            human_delay(4, 9)
            random_scroll(driver)
            human_delay(0.8, 2.0)

            # Locate "Following" button
            btn = find_unfollow_button(driver)
            if not btn:
                df.at[index, "Done ?"] = "❌ (Error)"
                print(f"❌ {username}: 'Following' / 'Tracked' button not found")
                continue

            # Click the "Following" button to trigger popup
            small_mouse_move(driver, btn)
            human_delay(0.4, 1.0)
            try:
                btn.click()
            except ElementClickInterceptedException:
                driver.execute_script("arguments[0].click();", btn)

            human_delay(0.5, 1.0)

            # Wait for the Unfollow popup to appear
            confirm_btn = None
            popup_keywords = ["ביטול מעקב", "ביטול המעקב", "Unfollow"]

            for _ in range(20):
                try:
                    all_buttons = driver.find_elements(By.XPATH, "//button | //div | //span")
                    popup_buttons = []
                    for b in all_buttons:
                        try:
                            txt = b.text.strip()
                            if any(k in txt for k in popup_keywords):
                                popup_buttons.append(b)
                        except Exception:
                            continue
                    if popup_buttons:
                        confirm_btn = popup_buttons[-1]  # Click last match (usually correct one)
                        break
                except Exception:
                    pass
                time.sleep(0.5)

            # If popup found, confirm unfollow
            if confirm_btn:
                human_delay(1.2, 2.2)
                small_mouse_move(driver, confirm_btn)
                human_delay(0.5, 1.2)
                try:
                    confirm_btn.click()
                    time.sleep(random.uniform(2.5, 3.8))
                    WebDriverWait(driver, 6).until_not(
                        EC.presence_of_element_located((By.XPATH, "//div[contains(@role, 'dialog')]"))
                    )
                except ElementClickInterceptedException:
                    driver.execute_script("arguments[0].click();", confirm_btn)
                except StaleElementReferenceException:
                    print("⚠️ Popup closed immediately after click — continuing normally.")
                df.at[index, "Done ?"] = "V"
                print(f"✅ Unfollowed {username}")
            else:
                df.at[index, "Done ?"] = "❌ Popup button not found"
                print(f"❌ {username}: Popup button not found")

        except Exception as e:
            # Catch unexpected errors and log them
            df.at[index, "Done ?"] = f"❌ ({type(e).__name__})"
            print(f"❌ {username}: Problem encountered: {e}")

        processed += 1

        # Save progress every few actions
        if processed % SAVE_EVERY == 0:
            df.to_excel(EXCEL_IN, index=False)
            print(f"\n💾 Saved after {processed} actions.\n")

        # Periodically take long breaks to avoid bot detection
        if processed % LONG_BREAK_EVERY == 0:
            print("\n⏸️ Taking a long break...\n")
            human_delay(LONG_BREAK_MIN, LONG_BREAK_MAX)

        # Random delay between users
        human_delay(3, 9)

    # ------------------------------------------ Save final results ------------------------------------------
    df.to_excel(EXCEL_IN, index=False)
    print(f"✨ Process completed. {processed} actions performed. File saved: {EXCEL_IN}")

    # Convert URLs into clickable hyperlinks in Excel
    from openpyxl import load_workbook
    from openpyxl.styles import Font

    wb = load_workbook(EXCEL_IN)
    ws = wb.active

    col_idx = df.columns.get_loc("Profile URL") + 1  # openpyxl uses 1-based indexing
    for row in range(2, ws.max_row + 1):
        cell = ws.cell(row=row, column=col_idx)
        url = cell.value
        if url and url.startswith("http"):
            cell.hyperlink = url
            cell.font = Font(color="0000FF", underline="single")  # Blue clickable link

    wb.save(EXCEL_IN)

    # Safely close browser
    try:
        driver.quit()
    except Exception:
        pass


# --------------------------------------------- Script entry point ---------------------------------------------
if __name__ == "__main__":
    main()
